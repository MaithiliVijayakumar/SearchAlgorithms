#include <stdio.h>
#include <limits.h>

#define MAX_NODES 10
#define INF 9999

typedef struct {
    int node;
    int g; // cost from start
    int f; // g + h
    int path[MAX_NODES];
    int pathLen;
} Node;

int closed[MAX_NODES];

void enqueue(Node queue[], int *size, Node newNode) {
    queue[(*size)++] = newNode;
    for (int i = 0; i < *size - 1; i++) {
        for (int j = i + 1; j < *size; j++) {
            if (queue[j].f < queue[i].f) {
                Node temp = queue[i];
                queue[i] = queue[j];
                queue[j] = temp;
            }
        }
    }
}

Node dequeue(Node queue[], int *size) {
    Node first = queue[0];
    for (int i = 0; i < *size - 1; i++) {
        queue[i] = queue[i + 1];
    }
    (*size)--;
    return first;
}

void aStar(int graph[MAX_NODES][MAX_NODES], int h[MAX_NODES], int start, int goal, int n) {
    Node open[100];
    int openSize = 0;

    Node startNode;
    startNode.node = start;
    startNode.g = 0;
    startNode.f = h[start];
    startNode.pathLen = 1;
    startNode.path[0] = start;

    enqueue(open, &openSize, startNode);

    while (openSize > 0) {
        Node current = dequeue(open, &openSize);

        printf("Expanding node %d with f=%d (g=%d, h=%d)\n",
               current.node, current.f, current.g, h[current.node]);

        if (current.node == goal) {
            printf("\nGoal reached!\nPath: ");
            for (int i = 0; i < current.pathLen; i++) {
                printf("%d", current.path[i]);
                if (i < current.pathLen - 1) printf(" -> ");
            }
            printf("\nTotal cost: %d\n", current.g);
            return;
        }

        closed[current.node] = 1; // mark as visited

        for (int neighbor = 0; neighbor < n; neighbor++) {
            if (graph[current.node][neighbor] > 0 && !closed[neighbor]) {
                int inPath = 0;
                for (int i = 0; i < current.pathLen; i++) {
                    if (current.path[i] == neighbor) {
                        inPath = 1;
                        break;
                    }
                }
                if (inPath) continue;

                Node next;
                next.node = neighbor;
                next.g = current.g + graph[current.node][neighbor];
                next.f = next.g + h[neighbor];
                next.pathLen = current.pathLen;

                for (int i = 0; i < current.pathLen; i++) {
                    next.path[i] = current.path[i];
                }
                next.path[next.pathLen++] = neighbor;

                enqueue(open, &openSize, next);
            }
        }
    }

    printf("Goal not reachable.\n");
}

int main() {
    int n = 7; 
    int graph[MAX_NODES][MAX_NODES] = {0};

    graph[0][1] = 3; graph[1][0] = 3; // S-A
    graph[0][2] = 5; graph[2][0] = 5; // S-B
    graph[1][4] = 4; graph[4][1] = 4; // A-D
    graph[2][3] = 6; graph[3][2] = 6; // B-C
    graph[2][5] = 2; graph[5][2] = 2; // B-E
    graph[4][6] = 5; graph[6][4] = 5; // D-G
    graph[3][6] = 7; graph[6][3] = 7; // C-G

    int heuristic[MAX_NODES] = {7, 6, 4, 5, 3, 6, 0};

    int startNode = 0; // S
    int goalNode = 6;  // G

    printf("A* Search:\n");
    aStar(graph, heuristic, startNode, goalNode, n);

    return 0;
}
