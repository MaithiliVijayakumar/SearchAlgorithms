#include <stdio.h>
#include <limits.h>

#define MAX_NODES 10
#define INF 9999

typedef struct {
    int node;
    int cost;
    int path[MAX_NODES];
    int pathLen;
} State;

int visited[MAX_NODES];

void enqueue(State queue[], int *size, State newState) {
    queue[(*size)++] = newState;
    // Sort by cost (smallest first)
    for (int i = 0; i < *size - 1; i++) {
        for (int j = i + 1; j < *size; j++) {
            if (queue[j].cost < queue[i].cost) {
                State temp = queue[i];
                queue[i] = queue[j];
                queue[j] = temp;
            }
        }
    }
}

State dequeue(State queue[], int *size) {
    State first = queue[0];
    for (int i = 0; i < *size - 1; i++) {
        queue[i] = queue[i + 1];
    }
    (*size)--;
    return first;
}

void branchAndBound(int graph[MAX_NODES][MAX_NODES], int start, int goal, int n) {
    State queue[100];
    int size = 0;

    State startState;
    startState.node = start;
    startState.cost = 0;
    startState.pathLen = 1;
    startState.path[0] = start;

    enqueue(queue, &size, startState);

    while (size > 0) {
        State current = dequeue(queue, &size);
        if (current.node == goal) {
            printf("Goal reached with cost %d\n", current.cost);
            printf("Path: ");
            for (int i = 0; i < current.pathLen; i++) {
                printf("%d", current.path[i]);
                if (i < current.pathLen - 1) printf(" -> ");
            }
            printf("\n");
            return;
        }

        for (int neighbor = 0; neighbor < n; neighbor++) {
            if (graph[current.node][neighbor] > 0) {
                int inPath = 0;
                for (int i = 0; i < current.pathLen; i++) {
                    if (current.path[i] == neighbor) {
                        inPath = 1;
                        break;
                    }
                }
                if (inPath) continue;

                State next;
                next.node = neighbor;
                next.cost = current.cost + graph[current.node][neighbor];
                next.pathLen = current.pathLen;
                for (int i = 0; i < current.pathLen; i++) {
                    next.path[i] = current.path[i];
                }
                next.path[next.pathLen++] = neighbor;

                enqueue(queue, &size, next);
            }
        }
    }

    printf("Goal not reachable.\n");
}

int main() {
    int n = 7; 
    int graph[MAX_NODES][MAX_NODES] = {0};
    graph[0][1] = 3; graph[1][0] = 3; // S-A
    graph[0][2] = 5; graph[2][0] = 5; // S-B
    graph[1][4] = 4; graph[4][1] = 4; // A-D
    graph[2][3] = 6; graph[3][2] = 6; // B-C
    graph[2][5] = 2; graph[5][2] = 2; // B-E
    graph[4][6] = 5; graph[6][4] = 5; // D-G
    graph[3][6] = 7; graph[6][3] = 7; // C-G

    int startNode = 0; // S
    int goalNode = 6;  // G

    printf("Branch and Bound Search:\n");
    branchAndBound(graph, startNode, goalNode, n);

    return 0;
}
